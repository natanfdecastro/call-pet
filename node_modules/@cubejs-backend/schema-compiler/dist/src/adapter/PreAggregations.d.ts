export class PreAggregations {
    static transformQueryToCanUseForm(query: any): {
        sortedDimensions: any[];
        sortedTimeDimensions: any;
        measures: any[];
        leafMeasureAdditive: boolean;
        leafMeasures: any[];
        hasNoTimeDimensionsWithoutGranularity: boolean;
        allFiltersWithinSelectedDimensions: boolean;
        isAdditive: boolean;
        granularityHierarchies: any;
        hasMultipliedMeasures: boolean;
    };
    static transformedQueryToReferences(query: any): {
        measures: any;
        dimensions: any;
        timeDimensions: any;
    };
    static canUsePreAggregationForTransformedQueryFn(transformedQuery: any, refs: any): any;
    static squashDimensions(query: any): any[];
    static hasCumulativeMeasures(query: any): boolean;
    constructor(query: any, historyQueries: any, cubeLatticeCache: any);
    query: any;
    historyQueries: any;
    cubeLatticeCache: any;
    cubeLattices: {};
    /**
     * @return {unknown[]}
     */
    preAggregationsDescription(): unknown[];
    preAggregationsDescriptionLocal(): any;
    preAggregationCubes(): any;
    preAggregationDescriptionsFor(foundPreAggregation: any): any;
    canPartitionsBeUsed(foundPreAggregation: any): any;
    addPartitionRangeTo(foundPreAggregation: any, dimension: any, range: any): any;
    partitionDimension(foundPreAggregation: any): {
        dimension: any;
        partitionDimension: any;
    };
    preAggregationDescriptionsForRecursive(cube: any, foundPreAggregation: any): any;
    preAggregationDescriptionFor(cube: any, foundPreAggregation: any): {
        preAggregationsSchema: any;
        tableName: any;
        loadSql: any;
        sql: any;
        dataSource: any;
        invalidateKeyQueries: any;
        refreshKeyRenewalThresholds: any;
        external: any;
        indexesSql: {
            indexName: any;
            sql: any;
        }[];
    };
    preAggregationTableName(cube: any, preAggregationName: any, preAggregation: any, skipSchema: any): any;
    findPreAggregationToUseForCube(cube: any): {
        preAggregationName: string;
        preAggregation: any;
        cube: any;
        references: any;
    } | null;
    canUsePreAggregationFn(query: any, refs: any): any;
    canUsePreAggregationAndCheckIfRefValid(query: any): (refs: any) => any;
    checkAutoRollupPreAggregationValid(refs: any): boolean;
    getCubeLattice(cube: any, preAggregationName: any, preAggregation: any): void;
    findPreAggregationForQuery(): {
        preAggregationName: any;
        preAggregation: any;
        cube: any;
        canUsePreAggregation: any;
        references: any;
    } | undefined;
    preAggregationForQuery: {
        preAggregationName: any;
        preAggregation: any;
        cube: any;
        canUsePreAggregation: any;
        references: any;
    } | undefined;
    findAutoRollupPreAggregationsForCube(cube: any, preAggregations: any): any[];
    rollupMatchResults(): {
        preAggregationName: any;
        preAggregation: any;
        cube: any;
        canUsePreAggregation: any;
        references: any;
    }[];
    findRollupPreAggregationsForCube(cube: any, canUsePreAggregation: any, preAggregations: any): {
        preAggregationName: any;
        preAggregation: any;
        cube: any;
        canUsePreAggregation: any;
        references: any;
    }[];
    buildRollupJoin(preAggObj: any, preAggObjsToJoin: any): any;
    preAggObjForJoin(preAggObjsToJoin: any, joinMembers: any, join: any): any;
    resolveJoinMembers(join: any): any;
    cubesFromPreAggregation(preAggObj: any): any[];
    evaluatedPreAggregationObj(cube: any, preAggregationName: any, preAggregation: any, canUsePreAggregation: any): {
        preAggregationName: any;
        preAggregation: any;
        cube: any;
        canUsePreAggregation: any;
        references: any;
    };
    rollupMatchResultDescriptions(): {
        name: any;
        tableName: any;
        references: any;
        canUsePreAggregation: any;
    }[];
    canUseTransformedQuery(): {
        sortedDimensions: any[];
        sortedTimeDimensions: any;
        measures: any[];
        leafMeasureAdditive: boolean;
        leafMeasures: any[];
        hasNoTimeDimensionsWithoutGranularity: boolean;
        allFiltersWithinSelectedDimensions: boolean;
        isAdditive: boolean;
        granularityHierarchies: any;
        hasMultipliedMeasures: boolean;
    };
    castGranularity(granularity: any): any;
    collectOriginalSqlPreAggregations(fn: any): {
        preAggregations: any[];
        result: any;
    };
    originalSqlPreAggregationQuery(cube: any, aggregation: any): any;
    rollupPreAggregationQuery(cube: any, aggregation: any): any;
    autoRollupPreAggregationQuery(cube: any, aggregation: any): any;
    mergePartitionTimeDimensions(aggregation: any, partitionTimeDimensions: any): any;
    autoRollupNameSuffix(cube: any, aggregation: any): string;
    evaluateAllReferences(cube: any, aggregation: any): any;
    originalSqlPreAggregationTable(preAggregationDescription: any): any;
    rollupPreAggregation(preAggregationForQuery: any): any;
    partitionUnion(preAggregationForQuery: any): any;
}
//# sourceMappingURL=PreAggregations.d.ts.map