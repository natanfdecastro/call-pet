"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SqliteQuery = void 0;
const moment = __importStar(require("moment-timezone"));
const BaseQuery_1 = require("./BaseQuery");
const BaseFilter_1 = require("./BaseFilter");
const GRANULARITY_TO_INTERVAL = {
    day: (date) => `strftime('%Y-%m-%dT00:00:00.000', ${date})`,
    week: (date) => `strftime('%Y-%m-%dT00:00:00.000', CASE WHEN date(${date}, 'weekday 1') = date(${date}) THEN date(${date}, 'weekday 1') ELSE date(${date}, 'weekday 1', '-7 days') END)`,
    hour: (date) => `strftime('%Y-%m-%dT%H:00:00.000', ${date})`,
    minute: (date) => `strftime('%Y-%m-%dT%H:%M:00.000', ${date})`,
    second: (date) => `strftime('%Y-%m-%dT%H:%M:%S.000', ${date})`,
    month: (date) => `strftime('%Y-%m-01T00:00:00.000', ${date})`,
    year: (date) => `strftime('%Y-01-01T00:00:00.000', ${date})`
};
class SqliteFilter extends BaseFilter_1.BaseFilter {
    likeIgnoreCase(column, not, param) {
        return `${column}${not ? ' NOT' : ''} LIKE '%' || ${this.allocateParam(param)} || '%' COLLATE NOCASE`;
    }
}
class SqliteQuery extends BaseQuery_1.BaseQuery {
    newFilter(filter) {
        return new SqliteFilter(this, filter);
    }
    convertTz(field) {
        return `${this.timeStampCast(field)} || '${moment().tz(this.timezone).format('Z')
            .replace('-', '+')
            .replace('+', '-')}'`;
    }
    floorSql(numeric) {
        // SQLite doesnt support FLOOR
        return `(CAST((${numeric}) as int) - ((${numeric}) < CAST((${numeric}) as int)))`;
    }
    timeStampCast(value) {
        return `strftime('%Y-%m-%dT%H:%M:%f', ${value})`;
    }
    dateTimeCast(value) {
        return `strftime('%Y-%m-%dT%H:%M:%f', ${value})`;
    }
    subtractInterval(date, interval) {
        return `strftime('%Y-%m-%dT%H:%M:%f', ${date}, '${interval.replace('-', '+').replace(/(^\+|^)/, '-')}')`;
    }
    addInterval(date, interval) {
        return `strftime('%Y-%m-%dT%H:%M:%f', ${date}, '${interval}')`;
    }
    timeGroupedColumn(granularity, dimension) {
        return GRANULARITY_TO_INTERVAL[granularity](dimension);
    }
    seriesSql(timeDimension) {
        const values = timeDimension.timeSeries().map(([from, to]) => `select '${from}' f, '${to}' t`).join(' UNION ALL ');
        return `SELECT dates.f date_from, dates.t date_to FROM (${values}) AS dates`;
    }
    nowTimestampSql() {
        // eslint-disable-next-line quotes
        return `strftime('%Y-%m-%dT%H:%M:%fZ', 'now')`;
    }
    unixTimestampSql() {
        // eslint-disable-next-line quotes
        return `strftime('%s','now')`;
    }
}
exports.SqliteQuery = SqliteQuery;
//# sourceMappingURL=SqliteQuery.js.map