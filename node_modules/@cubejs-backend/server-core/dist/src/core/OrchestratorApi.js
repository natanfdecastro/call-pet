"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrchestratorApi = void 0;
/* eslint-disable no-throw-literal */
const promise_timeout_1 = __importDefault(require("promise-timeout"));
const query_orchestrator_1 = require("@cubejs-backend/query-orchestrator");
class OrchestratorApi {
    constructor(driverFactory, logger, options = {}) {
        this.driverFactory = driverFactory;
        this.logger = logger;
        this.options = options;
        this.seenDataSources = {};
        const { externalDriverFactory } = options;
        this.continueWaitTimeout = this.options.continueWaitTimeout || 5;
        this.orchestrator = new query_orchestrator_1.QueryOrchestrator(options.redisPrefix || 'STANDALONE', driverFactory, logger, options);
        this.driverFactory = driverFactory;
        this.externalDriverFactory = externalDriverFactory;
        this.logger = logger;
    }
    async executeQuery(query) {
        const queryForLog = query.query && query.query.replace(/\s+/g, ' ');
        const startQueryTime = (new Date()).getTime();
        try {
            this.logger('Query started', {
                query: queryForLog,
                params: query.values,
                requestId: query.requestId
            });
            let fetchQueryPromise = query.loadRefreshKeysOnly ?
                this.orchestrator.loadRefreshKeys(query) :
                this.orchestrator.fetchQuery(query);
            fetchQueryPromise = promise_timeout_1.default.timeout(fetchQueryPromise, this.continueWaitTimeout * 1000);
            const data = await fetchQueryPromise;
            this.logger('Query completed', {
                duration: ((new Date()).getTime() - startQueryTime),
                query: queryForLog,
                params: query.values,
                requestId: query.requestId
            });
            return data;
        }
        catch (err) {
            if ((err instanceof promise_timeout_1.default.TimeoutError || err instanceof query_orchestrator_1.ContinueWaitError)) {
                this.logger('Continue wait', {
                    duration: ((new Date()).getTime() - startQueryTime),
                    query: queryForLog,
                    params: query.values,
                    requestId: query.requestId
                });
                const fromCache = await this.orchestrator.resultFromCacheIfExists(query);
                if (!query.renewQuery && fromCache && !query.scheduledRefresh) {
                    this.logger('Slow Query Warning', {
                        query: queryForLog,
                        requestId: query.requestId,
                        warning: 'Query is too slow to be renewed during the user request and was served from the cache. Please consider using low latency pre-aggregations.'
                    });
                    return {
                        ...fromCache,
                        slowQuery: true
                    };
                }
                throw {
                    error: 'Continue wait',
                    stage: !query.scheduledRefresh ? await this.orchestrator.queryStage(query) : null
                };
            }
            this.logger('Error querying db', {
                query: queryForLog,
                params: query.values,
                error: (err.stack || err),
                requestId: query.requestId
            });
            throw { error: err.toString() };
        }
    }
    async testConnection() {
        return Promise.all([
            ...Object.keys(this.seenDataSources).map(ds => this.testDriverConnection(this.driverFactory, ds)),
            this.testDriverConnection(this.externalDriverFactory)
        ]);
    }
    async testOrchestratorConnections() {
        return this.orchestrator.testConnections();
    }
    async testDriverConnection(driverFn, dataSource = 'default') {
        if (driverFn) {
            const driver = await driverFn(dataSource);
            await driver.testConnection();
        }
    }
    async release() {
        return Promise.all([
            ...Object.keys(this.seenDataSources).map(ds => this.releaseDriver(this.driverFactory, ds)),
            this.releaseDriver(this.externalDriverFactory),
            this.orchestrator.cleanup()
        ]);
    }
    async releaseDriver(driverFn, dataSource = 'default') {
        if (driverFn) {
            const driver = await driverFn(dataSource);
            if (driver.release) {
                await driver.release();
            }
        }
    }
    addDataSeenSource(dataSource) {
        this.seenDataSources[dataSource] = true;
    }
}
exports.OrchestratorApi = OrchestratorApi;
//# sourceMappingURL=OrchestratorApi.js.map