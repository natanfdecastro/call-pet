/// <reference types="node" />
import LRUCache from 'lru-cache';
import { ApiGateway } from '@cubejs-backend/api-gateway';
import { CancelableInterval } from '@cubejs-backend/shared';
import type { Application as ExpressApplication } from 'express';
import type { BaseDriver } from '@cubejs-backend/query-orchestrator';
import type { Constructor } from '@cubejs-backend/shared';
import type { ContextToAppIdFn, CreateOptions, DatabaseType, DbTypeFn, ExternalDbTypeFn, OrchestratorOptionsFn, PreAggregationsSchemaFn, RequestContext, DriverContext, SchemaFileRepository, UserBackgroundContext } from './types';
import { FileRepository } from './FileRepository';
import { RefreshScheduler } from './RefreshScheduler';
import { OrchestratorApi } from './OrchestratorApi';
import { CompilerApi } from './CompilerApi';
import { DevServer } from './DevServer';
import { OrchestratorStorage } from './OrchestratorStorage';
declare type RequireOne<T, K extends keyof T> = {
    [X in Exclude<keyof T, K>]?: T[X];
} & {
    [P in K]-?: T[P];
};
export declare type ServerCoreInitializedOptions = RequireOne<CreateOptions, 'dbType' | 'apiSecret' | 'devServer' | 'telemetry' | 'logger' | 'dashboardAppPath' | 'dashboardAppPort' | 'driverFactory' | 'dialectFactory' | 'externalDriverFactory' | 'externalDialectFactory' | 'scheduledRefreshContexts'>;
export declare class CubejsServerCore {
    readonly repository: FileRepository;
    protected devServer: DevServer | undefined;
    protected readonly orchestratorStorage: OrchestratorStorage;
    protected readonly repositoryFactory: ((context: RequestContext) => SchemaFileRepository) | (() => FileRepository);
    protected readonly contextToDbType: DbTypeFn;
    protected contextToExternalDbType: ExternalDbTypeFn;
    protected compilerCache: LRUCache<string, CompilerApi>;
    protected contextToOrchestratorId: any;
    protected readonly preAggregationsSchema: PreAggregationsSchemaFn;
    protected readonly orchestratorOptions: OrchestratorOptionsFn;
    logger: (type: string, params: Record<string, any>) => void;
    protected preAgentLogger: any;
    protected readonly options: ServerCoreInitializedOptions;
    protected readonly contextToAppId: ContextToAppIdFn;
    protected readonly standalone: boolean;
    protected maxCompilerCacheKeep: NodeJS.Timeout | null;
    protected scheduledRefreshTimerInterval: CancelableInterval | null;
    protected driver: BaseDriver | null;
    protected apiGatewayInstance: ApiGateway | null;
    readonly event: (name: string, props?: object) => Promise<void>;
    projectFingerprint: string | null;
    anonymousId: string | null;
    coreServerVersion: string | null;
    constructor(opts?: CreateOptions);
    private requireCubeStoreDriver;
    protected handleConfiguration(opts: CreateOptions): ServerCoreInitializedOptions;
    configFileExists(): boolean;
    protected detectScheduledRefreshTimer(scheduledRefreshTimer: number | boolean): number | false;
    protected initAgent(): void;
    protected flushAgent(): Promise<void>;
    static create(options?: CreateOptions): CubejsServerCore;
    initApp(app: ExpressApplication): Promise<void>;
    initSubscriptionServer(sendMessage: any): import("@cubejs-backend/api-gateway/dist/src/SubscriptionServer").SubscriptionServer;
    protected apiGateway(): ApiGateway;
    getCompilerApi(context: RequestContext): CompilerApi;
    getOrchestratorApi(context: RequestContext): OrchestratorApi;
    protected createCompilerApi(repository: any, options: any): CompilerApi;
    protected createOrchestratorApi(options?: any): OrchestratorApi;
    /**
     * @internal Please dont use this method directly, use refreshTimer
     */
    handleScheduledRefreshInterval: (options: any) => Promise<{
        finished: boolean;
    }[]>;
    protected getRefreshScheduler(): RefreshScheduler;
    /**
     * @internal Please dont use this method directly, use refreshTimer
     */
    runScheduledRefresh(context: UserBackgroundContext | null, queryingOptions?: any): Promise<{
        finished: boolean;
    }>;
    protected warningBackgroundContextShow: boolean;
    protected migrateBackgroundContext(ctx: UserBackgroundContext | null): RequestContext | null;
    getDriver(ctx: DriverContext): Promise<BaseDriver>;
    static createDriver(dbType: DatabaseType): BaseDriver;
    protected static lookupDriverClass(dbType: any): Constructor<BaseDriver> & {
        dialectClass?: () => any;
    };
    static driverDependencies(dbType: DatabaseType): string;
    testConnections(): Promise<any[]>;
    releaseConnections(): Promise<void>;
    beforeShutdown(): Promise<void>;
    protected causeErrorPromise: Promise<any> | null;
    protected onUncaughtException: (e: Error) => Promise<never>;
    shutdown(): Promise<void>;
    static version(): any;
}
export {};
//# sourceMappingURL=server.d.ts.map