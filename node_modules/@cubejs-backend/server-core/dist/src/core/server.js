"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CubejsServerCore = void 0;
/* eslint-disable global-require */
const crypto_1 = __importDefault(require("crypto"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const lru_cache_1 = __importDefault(require("lru-cache"));
const is_docker_1 = __importDefault(require("is-docker"));
const api_gateway_1 = require("@cubejs-backend/api-gateway");
const shared_1 = require("@cubejs-backend/shared");
const FileRepository_1 = require("./FileRepository");
const RefreshScheduler_1 = require("./RefreshScheduler");
const OrchestratorApi_1 = require("./OrchestratorApi");
const CompilerApi_1 = require("./CompilerApi");
const DevServer_1 = require("./DevServer");
const agentCollect_1 = __importDefault(require("./agentCollect"));
const OrchestratorStorage_1 = require("./OrchestratorStorage");
const logger_1 = require("./logger");
const DriverDependencies_1 = __importDefault(require("./DriverDependencies"));
const optionsValidate_1 = __importDefault(require("./optionsValidate"));
const { version } = require('../../../package.json');
const checkEnvForPlaceholders = () => {
    const placeholderSubstr = '<YOUR_DB_';
    const credentials = [
        'CUBEJS_DB_HOST',
        'CUBEJS_DB_NAME',
        'CUBEJS_DB_USER',
        'CUBEJS_DB_PASS'
    ];
    if (credentials.find((credential) => (process.env[credential] && process.env[credential].indexOf(placeholderSubstr) === 0))) {
        throw new Error('Your .env file contains placeholders in DB credentials. Please replace them with your DB credentials.');
    }
};
function wrapToFnIfNeeded(possibleFn) {
    if (typeof possibleFn === 'function') {
        return possibleFn;
    }
    return () => possibleFn;
}
class CubejsServerCore {
    constructor(opts = {}) {
        this.orchestratorStorage = new OrchestratorStorage_1.OrchestratorStorage();
        this.contextToAppId = () => process.env.CUBEJS_APP || 'STANDALONE';
        this.standalone = true;
        this.maxCompilerCacheKeep = null;
        this.scheduledRefreshTimerInterval = null;
        this.driver = null;
        this.apiGatewayInstance = null;
        this.projectFingerprint = null;
        this.anonymousId = null;
        this.coreServerVersion = null;
        this.requireCubeStoreDriver = () => shared_1.requireFromPackage('@cubejs-backend/cubestore-driver', {
            relative: shared_1.isDockerImage(),
            silent: true,
        });
        /**
         * @internal Please dont use this method directly, use refreshTimer
         */
        this.handleScheduledRefreshInterval = async (options) => {
            const contexts = await this.options.scheduledRefreshContexts();
            if (contexts.length < 1) {
                this.logger('Refresh Scheduler Error', {
                    error: 'At least one context should be returned by scheduledRefreshContexts'
                });
            }
            return Promise.all(contexts.map(async (context) => {
                const queryingOptions = { ...options, concurrency: this.options.scheduledRefreshConcurrency };
                if (this.options.scheduledRefreshTimeZones) {
                    queryingOptions.timezones = this.options.scheduledRefreshTimeZones;
                }
                return this.runScheduledRefresh(context, queryingOptions);
            }));
        };
        this.warningBackgroundContextShow = false;
        this.causeErrorPromise = null;
        this.onUncaughtException = async (e) => {
            console.error(e.stack || e);
            if (e.message && e.message.indexOf('Redis connection to') !== -1) {
                console.log('ðŸ›‘ Cube.js Server requires locally running Redis instance to connect to');
                if (process.platform.indexOf('win') === 0) {
                    console.log('ðŸ’¾ To install Redis on Windows please use https://github.com/MicrosoftArchive/redis/releases');
                }
                else if (process.platform.indexOf('darwin') === 0) {
                    console.log('ðŸ’¾ To install Redis on Mac please use https://redis.io/topics/quickstart or `$ brew install redis`');
                }
                else {
                    console.log('ðŸ’¾ To install Redis please use https://redis.io/topics/quickstart');
                }
            }
            if (!this.causeErrorPromise) {
                this.causeErrorPromise = this.event('Dev Server Fatal Error', {
                    error: (e.stack || e.message || e).toString()
                });
            }
            await this.causeErrorPromise;
            process.exit(1);
        };
        this.options = this.handleConfiguration(opts);
        this.logger = this.options.logger;
        this.repository = new FileRepository_1.FileRepository(this.options.schemaPath);
        this.repositoryFactory = this.options.repositoryFactory || (() => this.repository);
        this.contextToDbType = wrapToFnIfNeeded(this.options.dbType);
        this.contextToExternalDbType = wrapToFnIfNeeded(this.options.externalDbType);
        this.preAggregationsSchema = wrapToFnIfNeeded(this.options.preAggregationsSchema);
        this.orchestratorOptions = wrapToFnIfNeeded(this.options.orchestratorOptions);
        this.compilerCache = new lru_cache_1.default({
            max: this.options.compilerCacheSize || 250,
            maxAge: this.options.maxCompilerCacheKeepAlive,
            updateAgeOnGet: this.options.updateCompilerCacheKeepAlive
        });
        if (this.options.contextToAppId) {
            this.contextToAppId = this.options.contextToAppId;
            this.standalone = false;
        }
        if (this.options.contextToDataSourceId) {
            throw new Error('contextToDataSourceId has been deprecated and removed. Use contextToOrchestratorId instead.');
        }
        this.contextToOrchestratorId = this.options.contextToOrchestratorId || this.contextToAppId;
        // proactively free up old cache values occasionally
        if (this.options.maxCompilerCacheKeepAlive) {
            this.maxCompilerCacheKeep = setInterval(() => this.compilerCache.prune(), this.options.maxCompilerCacheKeepAlive);
        }
        const scheduledRefreshTimer = this.detectScheduledRefreshTimer(this.options.scheduledRefreshTimer);
        if (scheduledRefreshTimer) {
            this.scheduledRefreshTimerInterval = shared_1.createCancelableInterval(() => this.handleScheduledRefreshInterval({}), {
                interval: scheduledRefreshTimer,
                onDuplicatedExecution: (intervalId) => this.logger('Refresh Scheduler Interval Error', {
                    error: `Previous interval #${intervalId} was not finished with ${scheduledRefreshTimer} interval`
                }),
                onDuplicatedStateResolved: (intervalId, elapsed) => this.logger('Refresh Scheduler Long Execution', {
                    warning: `Interval #${intervalId} finished after ${shared_1.formatDuration(elapsed)}`
                })
            });
        }
        this.event = async (name, props) => {
            if (!this.options.telemetry) {
                return;
            }
            if (!this.projectFingerprint) {
                try {
                    this.projectFingerprint = crypto_1.default.createHash('md5')
                        .update(JSON.stringify(fs_extra_1.default.readJsonSync('package.json')))
                        .digest('hex');
                }
                catch (e) {
                    shared_1.internalExceptions(e);
                }
            }
            if (!this.anonymousId) {
                this.anonymousId = shared_1.getAnonymousId();
            }
            if (!this.coreServerVersion) {
                this.coreServerVersion = version;
            }
            const internalExceptionsEnv = shared_1.getEnv('internalExceptions');
            try {
                await shared_1.track({
                    event: name,
                    projectFingerprint: this.projectFingerprint,
                    coreServerVersion: this.coreServerVersion,
                    dockerVersion: shared_1.getEnv('dockerImageVersion'),
                    isDocker: is_docker_1.default(),
                    internalExceptions: internalExceptionsEnv !== 'false' ? internalExceptionsEnv : undefined,
                    ...props
                });
            }
            catch (e) {
                shared_1.internalExceptions(e);
            }
        };
        this.initAgent();
        if (this.options.devServer && !this.configFileExists()) {
            this.event('first_server_start');
        }
        if (this.options.devServer) {
            this.devServer = new DevServer_1.DevServer(this);
            const oldLogger = this.logger;
            this.logger = ((msg, params) => {
                if (msg === 'Load Request' ||
                    msg === 'Load Request Success' ||
                    msg === 'Orchestrator error' ||
                    msg === 'Internal Server Error' ||
                    msg === 'User Error' ||
                    msg === 'Compiling schema' ||
                    msg === 'Recompiling schema' ||
                    msg === 'Slow Query Warning') {
                    this.event(msg, { error: params.error });
                }
                oldLogger(msg, params);
            });
            if (!process.env.CI) {
                process.on('uncaughtException', this.onUncaughtException);
            }
        }
        else {
            const oldLogger = this.logger;
            let loadRequestCount = 0;
            this.logger = ((msg, params) => {
                if (msg === 'Load Request Success') {
                    loadRequestCount++;
                }
                oldLogger(msg, params);
            });
            setInterval(() => {
                this.event('Load Request Success Aggregated', { loadRequestSuccessCount: loadRequestCount });
                loadRequestCount = 0;
            }, 60000);
            this.event('Server Start');
        }
    }
    handleConfiguration(opts) {
        var _a;
        optionsValidate_1.default(opts);
        const dbType = opts.dbType || process.env.CUBEJS_DB_TYPE;
        const externalDbType = opts.externalDbType || process.env.CUBEJS_EXT_DB_TYPE;
        const devServer = process.env.NODE_ENV !== 'production' || process.env.CUBEJS_DEV_MODE === 'true';
        const logger = opts.logger || (process.env.NODE_ENV !== 'production'
            ? logger_1.devLogger(process.env.CUBEJS_LOG_LEVEL)
            : logger_1.prodLogger(process.env.CUBEJS_LOG_LEVEL));
        let externalDriverFactory = externalDbType && (() => new (CubejsServerCore.lookupDriverClass(externalDbType))({
            url: process.env.CUBEJS_EXT_DB_URL,
            host: process.env.CUBEJS_EXT_DB_HOST,
            database: process.env.CUBEJS_EXT_DB_NAME,
            port: process.env.CUBEJS_EXT_DB_PORT,
            user: process.env.CUBEJS_EXT_DB_USER,
            password: process.env.CUBEJS_EXT_DB_PASS,
        }));
        let externalDialectFactory = () => typeof externalDbType === 'string' &&
            CubejsServerCore.lookupDriverClass(externalDbType).dialectClass &&
            CubejsServerCore.lookupDriverClass(externalDbType).dialectClass();
        if (!externalDbType && shared_1.getEnv('devMode')) {
            const cubeStorePackage = this.requireCubeStoreDriver();
            if (cubeStorePackage) {
                if (cubeStorePackage.isCubeStoreSupported()) {
                    console.log(`ðŸ”¥ Cube Store (${version}) is assigned to 3030 port.`);
                    const cubeStoreHandler = new cubeStorePackage.CubeStoreHandler({
                        stdout: (data) => {
                            console.log(data.toString().trim());
                        },
                        stderr: (data) => {
                            console.log(data.toString().trim());
                        },
                        onRestart: (code) => logger('Cube Store Restarting', {
                            warning: `Instance exit with ${code}, restarting`,
                        }),
                    });
                    // Lazy loading for Cube Store
                    externalDriverFactory = () => new cubeStorePackage.CubeStoreDevDriver(cubeStoreHandler);
                    externalDialectFactory = () => cubeStorePackage.CubeStoreDevDriver.dialectClass();
                }
                else {
                    logger('Cube Store is not supported on your system', {
                        warning: (`You are using ${process.platform} platform with ${process.arch} architecture, ` +
                            'which is not supported by Cube Store.'),
                    });
                }
            }
        }
        const options = {
            dbType,
            externalDbType,
            devServer,
            driverFactory: () => typeof dbType === 'string' && CubejsServerCore.createDriver(dbType),
            dialectFactory: (ctx) => CubejsServerCore.lookupDriverClass(ctx.dbType).dialectClass &&
                CubejsServerCore.lookupDriverClass(ctx.dbType).dialectClass(),
            externalDriverFactory,
            externalDialectFactory,
            apiSecret: process.env.CUBEJS_API_SECRET,
            telemetry: process.env.CUBEJS_TELEMETRY !== 'false',
            scheduledRefreshTimeZones: process.env.CUBEJS_SCHEDULED_REFRESH_TIMEZONES &&
                process.env.CUBEJS_SCHEDULED_REFRESH_TIMEZONES.split(',').map(t => t.trim()),
            scheduledRefreshContexts: async () => [null],
            basePath: '/cubejs-api',
            dashboardAppPath: 'dashboard-app',
            dashboardAppPort: 3000,
            scheduledRefreshConcurrency: parseInt(process.env.CUBEJS_SCHEDULED_REFRESH_CONCURRENCY, 10),
            preAggregationsSchema: shared_1.getEnv('preAggregationsSchema') || (devServer ? 'dev_pre_aggregations' : 'prod_pre_aggregations'),
            schemaPath: process.env.CUBEJS_SCHEMA_PATH || 'schema',
            logger,
            scheduledRefreshTimer: shared_1.getEnv('scheduledRefresh') !== undefined ? shared_1.getEnv('scheduledRefresh') : shared_1.getEnv('refreshTimer'),
            sqlCache: true,
            livePreview: shared_1.getEnv('livePreview'),
            ...opts,
            jwt: {
                key: shared_1.getEnv('jwtKey'),
                algorithms: shared_1.getEnv('jwtAlgorithms'),
                issuer: shared_1.getEnv('jwtIssuer'),
                audience: shared_1.getEnv('jwtAudience'),
                subject: shared_1.getEnv('jwtSubject'),
                jwkUrl: shared_1.getEnv('jwkUrl'),
                claimsNamespace: shared_1.getEnv('jwtClaimsNamespace'),
                ...opts.jwt,
            }
        };
        if (opts.contextToAppId && !opts.scheduledRefreshContexts) {
            options.logger('Multitenancy Without ScheduledRefreshContexts', {
                warning: ('You are using multitenancy without configuring scheduledRefreshContexts, which can lead to issues where the ' +
                    'security context will be undefined while Cube.js will do background refreshing: ' +
                    'https://cube.dev/docs/config#options-reference-scheduled-refresh-contexts'),
            });
        }
        if (options.devServer && !options.apiSecret) {
            options.apiSecret = crypto_1.default.randomBytes(16).toString('hex');
            shared_1.displayCLIWarning(`Option apiSecret is required in dev mode. Cube.js has generated it as ${options.apiSecret}`);
        }
        if (!options.devServer || (options.devServer && this.configFileExists())) {
            const fieldsForValidation = [
                'driverFactory',
                'dbType'
            ];
            if (!((_a = options.jwt) === null || _a === void 0 ? void 0 : _a.jwkUrl)) {
                // apiSecret is required only for auth by JWT, for JWK it's not needed
                fieldsForValidation.push('apiSecret');
            }
            const invalidFields = fieldsForValidation.filter((field) => options[field] === undefined);
            if (invalidFields.length) {
                throw new Error(`${invalidFields.join(', ')} ${invalidFields.length === 1 ? 'is' : 'are'} required option(s)`);
            }
        }
        return options;
    }
    configFileExists() {
        return (fs_extra_1.default.existsSync('./.env') || fs_extra_1.default.existsSync('./cube.js'));
    }
    detectScheduledRefreshTimer(scheduledRefreshTimer) {
        if (scheduledRefreshTimer && (typeof scheduledRefreshTimer === 'number')) {
            return parseInt(scheduledRefreshTimer, 10) * 1000;
        }
        if (scheduledRefreshTimer) {
            return 30000;
        }
        return false;
    }
    initAgent() {
        if (process.env.CUBEJS_AGENT_ENDPOINT_URL) {
            const oldLogger = this.logger;
            this.preAgentLogger = oldLogger;
            this.logger = (msg, params) => {
                oldLogger(msg, params);
                agentCollect_1.default({
                    msg,
                    ...params
                }, process.env.CUBEJS_AGENT_ENDPOINT_URL, oldLogger);
            };
        }
    }
    async flushAgent() {
        if (process.env.CUBEJS_AGENT_ENDPOINT_URL) {
            await agentCollect_1.default({ msg: 'Flush Agent' }, process.env.CUBEJS_AGENT_ENDPOINT_URL, this.preAgentLogger);
        }
    }
    static create(options) {
        return new CubejsServerCore(options);
    }
    async initApp(app) {
        checkEnvForPlaceholders();
        const apiGateway = this.apiGateway();
        apiGateway.initApp(app);
        if (this.options.devServer) {
            this.devServer.initDevEnv(app, this.options);
        }
        else {
            app.get('/', (req, res) => {
                res.status(200)
                    .send('<html><body>Cube.js server is running in production mode. <a href="https://cube.dev/docs/deployment#production-mode">Learn more about production mode</a>.</body></html>');
            });
        }
    }
    initSubscriptionServer(sendMessage) {
        checkEnvForPlaceholders();
        const apiGateway = this.apiGateway();
        return apiGateway.initSubscriptionServer(sendMessage);
    }
    apiGateway() {
        if (!this.apiGatewayInstance) {
            this.apiGatewayInstance = new api_gateway_1.ApiGateway(this.options.apiSecret, this.getCompilerApi.bind(this), this.getOrchestratorApi.bind(this), this.logger, {
                standalone: this.standalone,
                dataSourceStorage: this.orchestratorStorage,
                basePath: this.options.basePath,
                checkAuthMiddleware: this.options.checkAuthMiddleware,
                checkAuth: this.options.checkAuth,
                queryTransformer: this.options.queryTransformer,
                extendContext: this.options.extendContext,
                playgroundAuthSecret: shared_1.getEnv('playgroundAuthSecret'),
                jwt: this.options.jwt,
                refreshScheduler: () => new RefreshScheduler_1.RefreshScheduler(this),
            });
        }
        return this.apiGatewayInstance;
    }
    getCompilerApi(context) {
        const appId = this.contextToAppId(context);
        let compilerApi = this.compilerCache.get(appId);
        const currentSchemaVersion = this.options.schemaVersion && (() => this.options.schemaVersion(context));
        if (!compilerApi) {
            compilerApi = this.createCompilerApi(this.repositoryFactory(context), {
                dbType: (dataSourceContext) => this.contextToDbType({ ...context, ...dataSourceContext }),
                externalDbType: this.contextToExternalDbType(context),
                dialectClass: (dialectContext) => this.options.dialectFactory &&
                    this.options.dialectFactory({ ...context, ...dialectContext }),
                externalDialectClass: this.options.externalDialectFactory && this.options.externalDialectFactory(context),
                schemaVersion: currentSchemaVersion,
                preAggregationsSchema: this.preAggregationsSchema(context),
                context,
                allowJsDuplicatePropsInSchema: this.options.allowJsDuplicatePropsInSchema
            });
            this.compilerCache.set(appId, compilerApi);
        }
        compilerApi.schemaVersion = currentSchemaVersion;
        return compilerApi;
    }
    getOrchestratorApi(context) {
        const orchestratorId = this.contextToOrchestratorId(context);
        if (this.orchestratorStorage.has(orchestratorId)) {
            return this.orchestratorStorage.get(orchestratorId);
        }
        const driverPromise = {};
        let externalPreAggregationsDriverPromise = null;
        const orchestratorApi = this.createOrchestratorApi({
            getDriver: async (dataSource = 'default') => {
                if (driverPromise[dataSource]) {
                    return driverPromise[dataSource];
                }
                // eslint-disable-next-line no-return-assign
                return driverPromise[dataSource] = (async () => {
                    let driver = null;
                    try {
                        driver = await this.options.driverFactory({ ...context, dataSource });
                        if (driver.setLogger) {
                            driver.setLogger(this.logger);
                        }
                        await driver.testConnection();
                        return driver;
                    }
                    catch (e) {
                        driverPromise[dataSource] = null;
                        if (driver) {
                            await driver.release();
                        }
                        throw e;
                    }
                })();
            },
            getExternalDriverFactory: this.options.externalDriverFactory && (async () => {
                if (externalPreAggregationsDriverPromise) {
                    return externalPreAggregationsDriverPromise;
                }
                // eslint-disable-next-line no-return-assign
                return externalPreAggregationsDriverPromise = (async () => {
                    let driver = null;
                    try {
                        driver = await this.options.externalDriverFactory(context);
                        if (driver.setLogger) {
                            driver.setLogger(this.logger);
                        }
                        await driver.testConnection();
                        return driver;
                    }
                    catch (e) {
                        externalPreAggregationsDriverPromise = null;
                        if (driver) {
                            await driver.release();
                        }
                        throw e;
                    }
                })();
            }),
            redisPrefix: orchestratorId,
            orchestratorOptions: this.orchestratorOptions(context)
        });
        this.orchestratorStorage.set(orchestratorId, orchestratorApi);
        return orchestratorApi;
    }
    createCompilerApi(repository, options) {
        options = options || {};
        return new CompilerApi_1.CompilerApi(repository, options.dbType || this.options.dbType, {
            schemaVersion: options.schemaVersion || this.options.schemaVersion,
            devServer: this.options.devServer,
            logger: this.logger,
            externalDbType: options.externalDbType,
            preAggregationsSchema: options.preAggregationsSchema,
            allowUngroupedWithoutPrimaryKey: this.options.allowUngroupedWithoutPrimaryKey,
            compileContext: options.context,
            dialectClass: options.dialectClass,
            externalDialectClass: options.externalDialectClass,
            allowJsDuplicatePropsInSchema: options.allowJsDuplicatePropsInSchema,
            sqlCache: this.options.sqlCache,
        });
    }
    createOrchestratorApi(options = {}) {
        return new OrchestratorApi_1.OrchestratorApi(options.getDriver || this.getDriver.bind(this), this.logger, {
            redisPrefix: options.redisPrefix || process.env.CUBEJS_APP,
            externalDriverFactory: options.getExternalDriverFactory,
            ...(options.orchestratorOptions || this.options.orchestratorOptions)
        });
    }
    getRefreshScheduler() {
        return new RefreshScheduler_1.RefreshScheduler(this);
    }
    /**
     * @internal Please dont use this method directly, use refreshTimer
     */
    async runScheduledRefresh(context, queryingOptions) {
        return this.getRefreshScheduler().runScheduledRefresh(this.migrateBackgroundContext(context), queryingOptions);
    }
    migrateBackgroundContext(ctx) {
        let result = null;
        // We renamed authInfo to securityContext, but users can continue to use both ways
        if (ctx) {
            if (ctx.securityContext && !ctx.authInfo) {
                result = {
                    ...ctx,
                    authInfo: ctx.securityContext,
                };
            }
            else if (ctx.authInfo) {
                result = {
                    ...ctx,
                    securityContext: ctx.authInfo,
                };
                if (this.warningBackgroundContextShow) {
                    this.logger('auth_info_deprecation', {
                        warning: ('authInfo was renamed to securityContext, please migrate: ' +
                            'https://github.com/cube-js/cube.js/blob/master/DEPRECATION.md#checkauthmiddleware')
                    });
                    this.warningBackgroundContextShow = false;
                }
            }
        }
        return result;
    }
    async getDriver(ctx) {
        if (!this.driver) {
            const driver = await this.options.driverFactory(ctx);
            await driver.testConnection(); // TODO mutex
            this.driver = driver;
        }
        return this.driver;
    }
    static createDriver(dbType) {
        checkEnvForPlaceholders();
        return new (CubejsServerCore.lookupDriverClass(dbType))();
    }
    static lookupDriverClass(dbType) {
        // eslint-disable-next-line global-require,import/no-dynamic-require
        const module = require(CubejsServerCore.driverDependencies(dbType || process.env.CUBEJS_DB_TYPE));
        if (module.default) {
            return module.default;
        }
        return module;
    }
    static driverDependencies(dbType) {
        if (DriverDependencies_1.default[dbType]) {
            return DriverDependencies_1.default[dbType];
        }
        else if (fs_extra_1.default.existsSync(path_1.default.join('node_modules', `${dbType}-cubejs-driver`))) {
            return `${dbType}-cubejs-driver`;
        }
        throw new Error(`Unsupported db type: ${dbType}`);
    }
    async testConnections() {
        return this.orchestratorStorage.testConnections();
    }
    async releaseConnections() {
        await this.orchestratorStorage.releaseConnections();
        if (this.maxCompilerCacheKeep) {
            clearInterval(this.maxCompilerCacheKeep);
        }
        if (this.scheduledRefreshTimerInterval) {
            await this.scheduledRefreshTimerInterval.cancel();
        }
    }
    async beforeShutdown() {
        if (this.maxCompilerCacheKeep) {
            clearInterval(this.maxCompilerCacheKeep);
        }
        if (this.scheduledRefreshTimerInterval) {
            await this.scheduledRefreshTimerInterval.cancel(true);
        }
    }
    async shutdown() {
        if (this.devServer) {
            if (!process.env.CI) {
                process.removeListener('uncaughtException', this.onUncaughtException);
            }
        }
        if (this.apiGatewayInstance) {
            this.apiGatewayInstance.release();
        }
        return this.orchestratorStorage.releaseConnections();
    }
    static version() {
        return version;
    }
}
exports.CubejsServerCore = CubejsServerCore;
//# sourceMappingURL=server.js.map