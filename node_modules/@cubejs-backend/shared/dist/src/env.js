"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isDockerImage = exports.getEnv = exports.asPortNumber = exports.convertTimeStrToMs = exports.InvalidConfiguration = void 0;
/* eslint-disable no-restricted-syntax */
const env_var_1 = require("env-var");
class InvalidConfiguration extends Error {
    constructor(key, value, description) {
        super(`Value "${value}" is not valid for ${key}. ${description}`);
    }
}
exports.InvalidConfiguration = InvalidConfiguration;
function convertTimeStrToMs(input, envName, description = 'Must be number (in seconds) or string in time format (1s, 1m, 1h).') {
    if (/^\d+$/.test(input)) {
        return parseInt(input, 10);
    }
    if (input.length > 1) {
        // eslint-disable-next-line default-case
        switch (input.substr(-1).toLowerCase()) {
            case 'h':
                return parseInt(input.slice(0, -1), 10) * 60 * 60;
            case 'm':
                return parseInt(input.slice(0, -1), 10) * 60;
            case 's':
                return parseInt(input.slice(0, -1), 10);
        }
    }
    throw new InvalidConfiguration(envName, input, description);
}
exports.convertTimeStrToMs = convertTimeStrToMs;
function asPortNumber(input, envName) {
    if (input < 0) {
        throw new InvalidConfiguration(envName, input, 'Should be a positive integer.');
    }
    if (input > 65535) {
        throw new InvalidConfiguration(envName, input, 'Should be lower or equal than 65535.');
    }
    return input;
}
exports.asPortNumber = asPortNumber;
function asPortOrSocket(input, envName) {
    if (/^-?\d+$/.test(input)) {
        return asPortNumber(parseInt(input, 10), envName);
    }
    // @todo Can we check that path for socket is valid?
    return input;
}
function asBoolOrTime(input, envName) {
    if (input.toLowerCase() === 'true') {
        return true;
    }
    if (input.toLowerCase() === 'false' || input === '0') {
        return false;
    }
    return convertTimeStrToMs(input, envName, 'Should be boolean or number (in seconds) or string in time format (1s, 1m, 1h)');
}
const variables = {
    devMode: () => env_var_1.get('CUBEJS_DEV_MODE')
        .default('false')
        .asBoolStrict(),
    port: () => asPortOrSocket(process.env.PORT || '4000', 'PORT'),
    tls: () => env_var_1.get('CUBEJS_ENABLE_TLS')
        .default('false')
        .asBoolStrict(),
    webSockets: () => env_var_1.get('CUBEJS_WEB_SOCKETS')
        .default('false')
        .asBoolStrict(),
    refreshTimer: () => {
        if (process.env.CUBEJS_SCHEDULED_REFRESH_TIMER) {
            return asBoolOrTime(process.env.CUBEJS_SCHEDULED_REFRESH_TIMER, 'CUBEJS_SCHEDULED_REFRESH_TIMER');
        }
        // Refresh timer is true by default for development
        return process.env.NODE_ENV !== 'production';
    },
    scheduledRefresh: () => env_var_1.get('CUBEJS_SCHEDULED_REFRESH')
        .asBool(),
    gracefulShutdown: () => env_var_1.get('CUBEJS_GRACEFUL_SHUTDOWN')
        .asIntPositive(),
    dockerImageVersion: () => env_var_1.get('CUBEJS_DOCKER_IMAGE_VERSION')
        .asString(),
    // It's only excepted for CI, nothing else.
    internalExceptions: () => env_var_1.get('INTERNAL_EXCEPTIONS_YOU_WILL_BE_FIRED')
        .default('false')
        .asEnum(['exit', 'log', 'false']),
    preAggregationsSchema: () => env_var_1.get('CUBEJS_PRE_AGGREGATIONS_SCHEMA')
        .asString(),
    dbPollTimeout: () => {
        const value = process.env.CUBEJS_DB_POLL_TIMEOUT || '15m';
        return convertTimeStrToMs(value, 'CUBEJS_DB_POLL_TIMEOUT');
    },
    dbPollMaxInterval: () => {
        const value = process.env.CUBEJS_DB_POLL_MAX_INTERVAL || '5s';
        return convertTimeStrToMs(value, 'CUBEJS_DB_POLL_MAX_INTERVAL');
    },
    // Common db options
    dbName: ({ required }) => env_var_1.get('CUBEJS_DB_NAME')
        .required(required)
        .asString(),
    // BigQuery Driver
    bigQueryLocation: () => env_var_1.get('CUBEJS_DB_BQ_LOCATION')
        .asString(),
    // Databricks
    databrickUrl: () => env_var_1.get('CUBEJS_DB_DATABRICKS_URL')
        .required()
        .asString(),
    databrickAcceptPolicy: () => env_var_1.get('CUBEJS_DB_DATABRICKS_ACCEPT_POLICY')
        .asString(),
    // Redis
    redisPoolMin: () => env_var_1.get('CUBEJS_REDIS_POOL_MIN')
        .default('2')
        .asInt(),
    redisPoolMax: () => env_var_1.get('CUBEJS_REDIS_POOL_MAX')
        .default('1000')
        .asInt(),
    redisUseIORedis: () => env_var_1.get('CUBEJS_REDIS_USE_IOREDIS')
        .default('false')
        .asBoolStrict(),
    redisUrl: () => env_var_1.get('REDIS_URL')
        .asString(),
    dbSsl: () => env_var_1.get('CUBEJS_DB_SSL')
        .default('false')
        .asBoolStrict(),
    dbSslRejectUnauthorized: () => env_var_1.get('CUBEJS_DB_SSL_REJECT_UNAUTHORIZED')
        .default('false')
        .asBoolStrict(),
    nodeEnv: () => env_var_1.get('NODE_ENV')
        .asString(),
    cacheAndQueueDriver: () => env_var_1.get('CUBEJS_CACHE_AND_QUEUE_DRIVER')
        .asString(),
    redisPassword: () => env_var_1.get('REDIS_PASSWORD')
        .asString(),
    redisTls: () => env_var_1.get('REDIS_TLS')
        .default('false')
        .asBoolStrict(),
    jwkUrl: () => env_var_1.get('CUBEJS_JWK_URL')
        .asString(),
    jwtKey: () => env_var_1.get('CUBEJS_JWT_KEY')
        .asUrlString(),
    jwtAlgorithms: () => env_var_1.get('CUBEJS_JWT_ALGS')
        .asArray(','),
    jwtAudience: () => env_var_1.get('CUBEJS_JWT_AUDIENCE')
        .asString(),
    jwtIssuer: () => env_var_1.get('CUBEJS_JWT_ISSUER')
        .asArray(','),
    jwtSubject: () => env_var_1.get('CUBEJS_JWT_SUBJECT')
        .asString(),
    jwtClaimsNamespace: () => env_var_1.get('CUBEJS_JWT_CLAIMS_NAMESPACE')
        .asString(),
    playgroundAuthSecret: () => env_var_1.get('CUBEJS_PLAYGROUND_AUTH_SECRET')
        .asString(),
    agentFrameSize: () => env_var_1.get('CUBEJS_AGENT_FRAME_SIZE')
        .default('200')
        .asInt(),
    livePreview: () => env_var_1.get('CUBEJS_LIVE_PREVIEW')
        .default('false')
        .asBoolStrict(),
};
function getEnv(key, opts) {
    if (key in variables) {
        return variables[key](opts);
    }
    throw new Error(`Unsupported env variable: "${key}"`);
}
exports.getEnv = getEnv;
function isDockerImage() {
    return Boolean(process.env.CUBEJS_DOCKER_IMAGE_TAG);
}
exports.isDockerImage = isDockerImage;
//# sourceMappingURL=env.js.map